## Завдання 1
У цьому завданні потрібно було реалізувати функції перетворення з бінарного представлення IEEE 754 чисел в текстове і назад.

### Компіляція
Через термінал:
```
g++ -std=c++11 -o ieee754 ieee_fp.cpp
./ieee754
```
а також Cmake:
```
mkdir build
cd build
cmake ..
cmake --build .
./ieee754
```

## Основна ідея перетворень
### На прикладі half precision:<br>
Формат представлення числа:<br>
| 1 біт знака | 5 біт експоненти | 10 біт мантиси |
Знак визначає чи є число від'ємним або додатнім, експонента - масштаб числа, мантиса - точність.

Почнемло з декодування, спочатку я читаю в окремі змінні знак, експоненту і мантису. Далі за значенням змінної знаку визначаємо 1 - від'ємне, 0 - додатнє. Далі відбувається обробка експоненти: 
- Якщо експонента дорівнює 0x1F (всі значення 1) - число є або безкінечністю (коли мантиса дорівнює 0), або NaN (коли мантиса не дорівнює 0).
- Якщо експонента дорівнює 0 (всі значення 0) - це денормалізоване число. Для денормалізованих чисел мантиса не має нормалізованого значення 1, і обчислення здійснюється так:<br>
```
float mantissa = fraction / std::pow(2.0f, 10);
return sign_val * std::pow(2, -14) * mantissa;
```
$2^{14}$ це коефіцієнт, який використовується для компенсації того, що мантиса не починається з 1 у денормалізованих чисел.
- Якщо експонента не 0x1F або 0 - тоді число нормалізоване і обчислюється наступним чином: <br>
```
float mantissa = 1 + (fraction / std::pow(2.0f, 10));
return sign_val * std::pow(2, exponent - 15) * mantissa;
```
Що є стандартним представленням для нормалізованих чисел.

Наступна xастина завдання - енкодування. <br>
Спочатку бітове представлення числа float копіюється у змінну типу uint32_t. Після чого як в декодуванні виділяється знак (1 біт), експонента (8 біт у float, 5 біт в half) і мантиса(23 біти у float, 10 біт у half).
Потім відповідно до завдання я обробила кейси з нескінченністю, NaN і нулем. Якщо число не підпало під жодне з попередніх обмежень:
- Якщо експонента більша або дорівнює максимально можливій у half (31), число вже не можна точно представити, тому повертається ±∞.
- Якщо експонента менша або рівна 0, число стає денормалізованим, тобто занадто малим, щоб його записати як нормальне число. У цьому випадку виконується спеціальне зсування мантиси, щоб хоча б приблизно представити його.
- Якщо ж число нормально вписується в діапазон half, експонента і мантиса просто обрізаються до розміру half і складаються назад у 16-бітове число.

### Для fp32 і fp64 алгоритми аналогічні.

## Тестування і огляд результатів
Моя мейн функція виглядає наступним чином:
```
std::cout << decode_half(0x3c00) << std::endl;
print_binary(encode_half(decode_half(0x3c00)));
```
де print_binary - функція для виводу бінарного представлення. <br>
Тобто я спочатку викликаю функцію decode а потім для результату - encode. <br>
Приклад виводу:
```
Half precision (decoding and encoding)
1
0011110000000000
6.09756e-05
0000001111111110
-2
1100000000000000
65504
0111101111111111
-inf
1111110000000000
nan
0111111000000000
nan
0111110100000000
Single precision (decoding and encoding)
1
00111111100000000000000000000000
3.14159
01000000010010010000111111011011
-2
11000000000000000000000000000000
3.40282e+38
01111111011111111111111111111111
inf
01111111100000000000000000000000
nan
01111111110000000000000000000000
nan
01111111101000000000000000000000
Double precision (decoding and encoding)
1
0011111111110000000000000000000000000000000000000000000000000000
4.94066e-324
0000000000000000000000000000000000000000000000000000000000000001
-2
1100000000000000000000000000000000000000000000000000000000000000
23
0100000000110111000000000000000000000000000000000000000000000000
inf
0111111111110000000000000000000000000000000000000000000000000000
nan
0111111111111000000000000000000000000000000000000000000000000000
nan
0111111111110100000000000000000000000000000000000000000000000000
```
тобто я розглянула кілька еджкейсів, відповідно до вимог завдання, а саме нормалізоване і денормалізоване число, inf а також від'ємні значення і різні види NaN.



